# webpack 简单示例
webpack.config.js文件
```
'use strict';

const path = require('path');

module.exports = {
    entry:'./src/index.js',
    output:{
        path:path.join(__dirname,'dist'),

        filename:'bunble.js'
    },
    mode:'production'
}
```
.src/holleworld.js文件
```
export function helloworld(){
    return 'Hello world';
}
```
.src/index.js文件
```
import {helloworld} from './holleworld';
document.write(helloworld())
```
package.json文件
```
{
  "name": "webpack_demo",
  "version": "1.0.0",
  "description": "",
  "main": "index.js",
  "scripts": {
    "test": "echo \"Error: no test specified\" && exit 1",
    "build":"webpack"
  },
  "author": "",
  "license": "ISC",
  "devDependencies": {
    "webpack": "^4.44.2",
    "webpack-cli": "^3.3.12"
  }
}
```
`"build":"webpack"`是后续增加上去的，目的是在项目路径中使用`npm run build`命令运行构建，原理：模块局部安装会在node_modules/.bin目录创建软连接，如果在script运行webpack，就会从node_modules中去寻找

# 基础用法
## entry
entry用来指定webpack的打包入口
为什么需要entry？
离不开webpack构建的机制，webpack是模块打包器，对于各种资源(.js\.css\.jpg\.png)都会打包成模块，各个模块之间都会存在依赖关系，所以要通过一个入口文件，先找入口文件中的依赖，入口文件依赖的文件也有依赖...会存在一棵依赖树，只要遇到依赖webpack会把依赖加入到依赖图中去，遍历完之后生成打包后的资源。
单入口：entry是一个字符串
```
module.exports = {
entry:'./path/file.js'
}
```
使用于一个项目里只有一个入口文件、只有一个页面或者单页应用
多入口：entry是一个对象
```
module.exports = {
    entry:{
      file:'./path/file.js',
      adminApp:'./src/adminApp.js'
      }
}
```
适用于多页面的场景，通常所说的多页应用
## output
output用来告诉webpack如何将编译后的文件输出到磁盘（转换之后的结果代码）包括输出的文件名称
单入口配置和多入口配置是针对entry而言，输出只有一个输出口
单入口配置
```
module.exports = {
entry:'./path/file.js',
output:{
        path:path.join(__dirname,'dist'),
        filename:'bunble.js'
    },
}
```
单入口配置`filename`文件名称和`path`输出的路径
多入口配置
```
module.exports = {
    entry:{
      file:'./path/file.js',
      adminApp:'./src/adminApp.js'
      },
    output:{
        path:path.join(__dirname,'dist'),
        filename:'[name].js'
    },
}
```
`[name]`通过占位符确保文件名称的唯一
## loaders
webpack开箱即用只支持JS和JSON两种文件类型，通过Loader去支持其他文件类型并且把它们转化成有效的模块，并且可以添加到依赖图中。
loaders本身是一个函数，接受源文件作为参数，返回转换的结果，转换结构后，在经过下一步去使用。
```
module.exports = {
    module:{
        rules:[
            {test:/\.txt$/,use:'raw-loader'}
        ]
    },
}
```
test指定匹配规则，use指定使用的loader名称
## plugins
插件用于bundle文件的优化，资源管理和环境变量的注入（任何loader没办法做的事情，可以通过plugins实现）
作用于整个构建过程
```
module.exports = {
    plugins:[
        new HtmlWebpackPlugin({template:'./src/index.html'})
    ]
}
```
## mode
webpack4提出的新概念
Mode用来指定当前的构建环境是：production\development\none
设置mode可以使用webpack内置的函数，默认值为production
设置development，process.env.NODE_ENV的值为development，开启NameChunksPlugin和NameModulesPlugin。
设置production，process.env.NODE_ENV的值为production，开启？？？？。
设置none，不开启任何优化选项

# 资源解析
## 解析ES6
需要使用babel-loader，babel的配置文件是：.babelrc
`npm i @babel/core @babel/preset-env babel-loader -D`
安装babel依赖，-D参数是--save-dev的简称（加到package.json中的devDependencies里）
在根目录创建`.babelrc`文件
```
{
    "presets": [
        "@babel/preset-env"
    ]
}
```
`"@babel/preset-env"`加入解析ES6环境
## 解析css
`npm i style-loader css-loader`
css-loader用于加载.css文件，并且转换成commonjs对象
style-loader将样式通过<style>标签插入到head中
```
module.exports = {
    module:{
        rules:[
            {test:/.js$/,use:'babel-loader'},
            {test:/.css$/,use:[
                'style-loader',
                'css-loader'
            ]}
        ]
    },
}
```
rules是链式调用，则从又向左调用，这样写会先调用css-loader解析css，再将解析好的css传递给style-loader
